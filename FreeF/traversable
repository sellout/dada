let Applicative =
      https://raw.githubusercontent.com/FormationAI/dhall-bhat/8afbcee6dfd092764df9e9456fe2a2650748dce2/Applicative/Type

let Foldable =
      https://raw.githubusercontent.com/FormationAI/dhall-bhat/8afbcee6dfd092764df9e9456fe2a2650748dce2/Foldable/Type

let Traversable =
      https://raw.githubusercontent.com/FormationAI/dhall-bhat/8afbcee6dfd092764df9e9456fe2a2650748dce2/Traversable/Type

let extractFoldable =
      https://raw.githubusercontent.com/FormationAI/dhall-bhat/8afbcee6dfd092764df9e9456fe2a2650748dce2/Traversable/extractFoldable

let extractFunctor =
      https://raw.githubusercontent.com/FormationAI/dhall-bhat/8afbcee6dfd092764df9e9456fe2a2650748dce2/Traversable/extractFunctor

in    λ(F : Type → Type)
    → λ(traversable : Traversable F)
    → λ(c : Type)
    →     { traverse =
                λ(G : Type → Type)
              → λ(applicative : Applicative G)
              → λ(a : Type)
              → λ(b : Type)
              → λ(f : a → G b)
              → λ(ts : ./Type F c a)
              → merge
                { Pure =
                      λ(x : c)
                    → applicative.pure (./Type F c b) ((./Type F c b).Pure x)
                , Free =
                      λ(x : F a)
                    → applicative.map
                      (F b)
                      (./Type F c b)
                      (λ(y : F b) → (./Type F c b).Free y)
                      (traversable.traverse G applicative a b f x)
                }
                ts
          }
        ∧   ./foldable F (extractFoldable F traversable) c
          ⫽ ./functor F (extractFunctor F traversable) c
      : Traversable (./Type F c)
